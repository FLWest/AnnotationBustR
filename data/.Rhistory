#' @example
#' data(Mito.Genes)#load the list of search terms for mitochondrial genes
#' add.name<-data.frame("D_loop","D-loop","note", "d-loop")#Create a data frame with a new search term.
#' colnames(add.names)<-colnames(Mito.Genes)# make the column names the same for combination.
#' MergeSearchTerms(add.name, Mito.Genes, sort.gene=FALSE)#Run the merge search term function without sorting based on gene name.
#' MergeSearchTerms(add.name, Mito.Genes, sort.gene=TRUE)#Run the merge search term function with sorting based on gene name.
#' @export
MergeSearchTerms<-function(..., sort.gene=FALSE){
dots <- list(...)
for (i in sequence(length(dots))) {
working <- TRUE
if(dim(dots[[i]])[2]!=4) {
working <- FALSE
}
if(class(dots[[i]])!="data.frame") {
working <- FALSE
}
if (!working) {
stop(paste("The ", i, "th input object is the wrong format", sep=""))
}
}
new.terms <- rbind(...)
if(sort.gene) {
new.terms <- new.terms[order(new.terms$gene),]
}
return(new.terms)
}
#' Find the longest sequence for each species from a list of GenBank accession numbers.
#'
#' @param accessions A vector of GenBank accession numbers.
#' @return A list of genbank accessions numbers for the longest sequence for each taxon in a list of accession numbers.
#' @example
#' genbank.accessions<-c("KP978059.1","KP978060.1","JX516105.1","JX516111.1")#vector of 4 genbank accessions, two each for two species
#' long.seq.result<-Find.Longest.Seq(genbank.accessions)#returns the longest sequence respectively for the two species.
#' @export
FindLongestSeq<-function(accessions){
multi.ncbi.hits<-NULL#empty vector for merging records
final.accession<-NULL#empty vector
x<-seq_along(accessions)#seq along all to get number
split.access <- split(accessions, ceiling(x/600))#break them up into groups of 600
for (i in 1:length(split.access)){
ncbi.hits<-traits::ncbi_byid(split.access[[i]])[,c(1,3:5)]#use the ropensci traits package to read the accession numbers
multi.ncbi.hits<-rbind(multi.ncbi.hits,ncbi.hits)#merge together all search hits given by merging to the ith multiple of 600
}
unique.taxa<-unique(multi.ncbi.hits$taxon)#get the names of taxa to find the longest seq
for(j in sequence(length(unique.taxa))){#for each taxa
current.spec<-subset(multi.ncbi.hits,multi.ncbi.hits$taxon==unique.taxa[[j]])#get the data for all the records for species j, minus the sequence
longest.seq<-subset(current.spec,current.spec$length==sort(as.numeric(current.spec$length),decreasing = TRUE)[1])[1,]#for all of the
final.accession<-rbind(final.accession,longest.seq)#combine individual rows into a data frame
}
row.names(final.accession)<-1:dim(final.accession)[1]#make row names the length of
final.accession#return final list
}
getwd()
setwd("C:/Users/Sam/Documents/GitHub/AnnotationBustR")
library(roxygen2)
roxygenise()
top.end<-setwd("C:/Users/Sam/Documents/GitHub/AnnotationBustR")
getwd()
roxygenise()
data(Mito.Genes)
test_that("merging search terms works", {
load("MitoGenes.RData")#load mito search terms
load("rDNA.RData")#load rDNA search terms
#No Sorting
reg_merged<-rbind(Mito.Genes, rDNA.Genes)#simple rbind
reg.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = FALSE)#run the function w/out sorting
expect_identical(dim(reg.test.merge), dim(reg_merged))#test to see if same dimensions
expect_identical(reg.test.merge[1,], reg_merged[1,])#test to see the first row is the same
expect_identical(reg.test.merge[167,], reg_merged[167,])#test to see the last row is the same
#With Sorting
sorted_merged<-reg_merged[order(reg_merged$gene),]
sort.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = TRUE)#run the function with sorting
expect_identical(dim(sort.test.merge), dim(sorted_merged))#test to see if same dimensions
expect_identical(sort.test.merge[1,], sorted_merged[1,])#test to see the first row is the same
expect_identical(sort.test.merge[167,], sorted_merged[167,])#test to see the last row is the same
})
library(testthat)
test_that("merging search terms works", {
load("MitoGenes.RData")#load mito search terms
load("rDNA.RData")#load rDNA search terms
#No Sorting
reg_merged<-rbind(Mito.Genes, rDNA.Genes)#simple rbind
reg.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = FALSE)#run the function w/out sorting
expect_identical(dim(reg.test.merge), dim(reg_merged))#test to see if same dimensions
expect_identical(reg.test.merge[1,], reg_merged[1,])#test to see the first row is the same
expect_identical(reg.test.merge[167,], reg_merged[167,])#test to see the last row is the same
#With Sorting
sorted_merged<-reg_merged[order(reg_merged$gene),]
sort.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = TRUE)#run the function with sorting
expect_identical(dim(sort.test.merge), dim(sorted_merged))#test to see if same dimensions
expect_identical(sort.test.merge[1,], sorted_merged[1,])#test to see the first row is the same
expect_identical(sort.test.merge[167,], sorted_merged[167,])#test to see the last row is the same
})
install.packages(c("arules", "R.utils", "rvertnet", "sp", "testthat"))
setwd("C:/Users/Sam/Documents/GitHub/AnnotationBustR/data")
test_that("merging search terms works", {
load("MitoGenes.RData")#load mito search terms
load("rDNA.RData")#load rDNA search terms
reg_merged<-rbind(Mito.Genes, rDNA.Genes)#simple rbind
#No Sorting
reg.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = FALSE)#run the function w/out sorting
expect_identical(dim(reg.test.merge), dim(reg_merged))#test to see if same dimensions
expect_identical(reg.test.merge[167,], reg_merged[167,])#test to see the last row is the same
expect_identical(reg.test.merge[1,], reg_merged[1,])#test to see the first row is the same
sorted_merged<-reg_merged[order(reg_merged$gene),]
#With Sorting
sort.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = TRUE)#run the function with sorting
expect_identical(dim(sort.test.merge), dim(sorted_merged))#test to see if same dimensions
expect_identical(sort.test.merge[1,], sorted_merged[1,])#test to see the first row is the same
expect_identical(sort.test.merge[167,], sorted_merged[167,])#test to see the last row is the same
})
library(testthat)
test_that("merging search terms works", {
load("MitoGenes.RData")#load mito search terms
load("rDNA.RData")#load rDNA search terms
#No Sorting
reg_merged<-rbind(Mito.Genes, rDNA.Genes)#simple rbind
reg.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = FALSE)#run the function w/out sorting
expect_identical(dim(reg.test.merge), dim(reg_merged))#test to see if same dimensions
expect_identical(reg.test.merge[1,], reg_merged[1,])#test to see the first row is the same
expect_identical(reg.test.merge[167,], reg_merged[167,])#test to see the last row is the same
#With Sorting
sorted_merged<-reg_merged[order(reg_merged$gene),]
sort.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = TRUE)#run the function with sorting
expect_identical(dim(sort.test.merge), dim(sorted_merged))#test to see if same dimensions
expect_identical(sort.test.merge[1,], sorted_merged[1,])#test to see the first row is the same
expect_identical(sort.test.merge[167,], sorted_merged[167,])#test to see the last row is the same
})
test_that("merging search terms works", {
load("MitoGenes.RData")#load mito search terms
load("rDNA.RData")#load rDNA search terms
#No Sorting
reg_merged<-rbind(Mito.Genes, rDNA.Genes)#simple rbind
reg.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = FALSE)#run the function w/out sorting
expect_identical(dim(reg.test.merge), dim(reg_merged))#test to see if same dimensions
expect_identical(reg.test.merge[1,], reg_merged[1,])#test to see the first row is the same
expect_identical(reg.test.merge[167,], reg_merged[167,])#test to see the last row is the same
#With Sorting
sorted_merged<-reg_merged[order(reg_merged$gene),]
sort.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = TRUE)#run the function with sorting
expect_identical(dim(sort.test.merge), dim(sorted_merged))#test to see if same dimensions
expect_identical(sort.test.merge[1,], sorted_merged[1,])#test to see the first row is the same
expect_identical(sort.test.merge[166,], sorted_merged[167,])#test to see the last row is the same
})
#Test to see if merge search terms works properly.
#Will merge rDNA and Mitogenome terms together, which will be included in the package as data.
#Do one to test if it merges and another to see if it sorts
test_that("merging search terms works", {
load("MitoGenes.RData")#load mito search terms
load("rDNA.RData")#load rDNA search terms
#No Sorting
reg_merged<-rbind(Mito.Genes, rDNA.Genes)#simple rbind
reg.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = FALSE)#run the function w/out sorting
expect_identical(dim(reg.test.merge), dim(reg_merged))#test to see if same dimensions
expect_identical(reg.test.merge[1,], reg_merged[1,])#test to see the first row is the same
expect_identical(reg.test.merge[167,], reg_merged[167,])#test to see the last row is the same
#With Sorting
sorted_merged<-reg_merged[order(reg_merged$gene),]
sort.test.merge<-MergeSearchTerms(Mito.Genes, rDNA.Genes, sort.gene = TRUE)#run the function with sorting
expect_identical(dim(sort.test.merge), dim(sorted_merged))#test to see if same dimensions
expect_identical(sort.test.merge[1,], sorted_merged[1,])#test to see the first row is the same
expect_identical(sort.test.merge[167,], sorted_merged[167,])#test to see the last row is the same
})
getwd()
test_that("Less than max query works to find longest seq",{
Aburt<-read.table("Aburt.txt")
Aburt<-Aburt$V1#8 Accession numbers for A. burtoni
correct.seq<-ncbi_byname("Haplochromis burtoni", gene="cytb")[,c(1,3:5)]#ncbi_byname from traits gets longest seq for the species for a gene
expect_identical(FindLongestSeq(Aburt)$acc_no, correct.seq$acc_no)
})
library(traits)
library(ape)
library(seqinr)
test_that("Less than max query works to find longest seq",{
Aburt<-read.table("Aburt.txt")
Aburt<-Aburt$V1#8 Accession numbers for A. burtoni
correct.seq<-ncbi_byname("Haplochromis burtoni", gene="cytb")[,c(1,3:5)]#ncbi_byname from traits gets longest seq for the species for a gene
expect_identical(FindLongestSeq(Aburt)$acc_no, correct.seq$acc_no)
})
test_that("Less than max query works to find longest seq",{
Aburt<-read.table("Aburt.txt")
Aburt<-Aburt$V1#8 Accession numbers for A. burtoni
correct.seq<-ncbi_byname("Haplochromis burtoni", gene="cytb")[,c(1,3:5)]#ncbi_byname from traits gets longest seq for the species for a gene
expect_identical(FindLongestSeq(Aburt)$gi_no, correct.seq$acc_no)
})
test_that("More than max query works to find longest seq",{
Achrist<-read.table("Achrist.txt")
Achrist<-Achrist$V1#1041 Accession numbers for A. burtoni
correct.seq<-ncbi_byname("Aristochromis christyi", gene="UCE")[,c(1,3:5)]#ncbi_byname from traits gets longest seq for the species for a gene
expect_identical(FindLongestSeq(Achrist)$acc_no, correct.seq$acc_no)
})
test_that("More than max query works to find longest seq",{
Achrist<-read.table("Achrist.txt")
Achrist<-Achrist$V1#1041 Accession numbers for A. burtoni
correct.seq<-ncbi_byname("Aristochromis christyi", gene="UCE")[,c(1,3:5)]#ncbi_byname from traits gets longest seq for the species for a gene
expect_identical(FindLongestSeq(Achrist)$gi_no, correct.seq$acc_no)
})
GetSeqPos<-function(accessions, genes, duplicate.genes =c("tRNA_Ser2", "tRNA_Leu2")){
seqinr::choosebank("genbank")#choose bank so it could be genbank or EMBL or others supported?
unique.gene.names <- unique(genes$gene)#unique gene names
seq.col.id<-paste(rep(as.vector(unique.gene.names),1,each=2),c("start","stop"),sep = ".")#these will be the column names for gene id
boundaries <- data.frame(matrix(nrow=length(accessions), ncol=2+2*length(unique.gene.names)))
#for each accession
for(i in sequence(length(accessions))){
new.access<-strsplit(accessions[i],"\\.",perl=TRUE)[[1]][1]#split and decimal spot in accession number. seqinr won't take them with it
rec<-seqinr::query(paste("AC=",new.access,sep=""))#get the genbank record. Getting error related to paste and it won't show accession, but it is working.
current.annot<-seqinr::getAnnot(rec$req[[1]],nbl=20000)#I think nbl is ok, but maybe we should up it to something ridiculous just to be safe
new.annot<-gsub("complement\\(|\\(|<"," ",current.annot)#kill complement()
new.annot<-gsub("\\)|>","",new.annot)#kill trailing ) after complemet
matching.lines.Leu<-which(grepl("tRNA-Leu|trnL|trnL-uaa|trnL TAA",new.annot))#find Leucine lines
new.annot[matching.lines.Leu[1]]<-sub("tRNA-Leu|trnL|trnL-uaa|trnL TAA","tRNA-Leu1",new.annot[matching.lines.Leu[1]])#sub 1st leucine instance
matching.lines.Ser<-which(grepl("tRNA-Ser|trnS|trnS-uga|trnS TGA",new.annot))#find serine lines
new.annot[matching.lines.Ser[1]]<-sub("tRNA-Ser|trnS|trnS-uga|trnS TGA","tRNA-Ser1",new.annot[matching.lines.Ser[1]])#sub first instance of serine
spec.name<- subset(gsub("  ORGANISM  ", "",str_extract_all(new.annot, "  ORGANISM  \\D+")),!(gsub("  ORGANISM  ", "",str_extract_all(new.annot, "  ORGANISM  \\D+"))=="character(0)"))#get species name
boundaries[i, 1] <- spec.name#add species name to final table
boundaries[i, 2] <- accessions[i]#add accession number to the final table
#for each gene
for (j in sequence(length(unique.gene.names))) {
genes.local <- subset(genes, genes$gene==unique.gene.names[j])#subset genes based on column 1 ID
found.result <- matrix(nrow=1, ncol=3)#make empty result so if nothing is found, it is NA
#for each search term combo
for (k in sequence(dim(genes.local)[1])) {
found.result.match <- stringr::str_match_all(paste(new.annot, collapse=" "), paste(genes.local[k,2],"\\s+(\\d+)..(\\d+)\\s*+/*",genes.local[k,3],"=*\\\"*", genes.local[k,4], "\\\"*", sep=""))#Match all cases for genes with duplicates tRNA in this case
#found.result.match <- str_match_all(paste(new.annot, collapse=" "), paste(genes[i,2],"\\s+(\\d+)..(\\d+)\\s+/",genes[i,3],"=\\\"", genes[i,4], "\\\"", sep=""))#Match all cases for genes with duplicates tRNA in this case
#found.result.match <- str_match_all(paste(new.annot, collapse=" "), paste(genes[i,2],"\\s+(\\d+)..(\\d+)\\s+/",genes[i,3], genes[i,4], sep=""))#Match all cases for genes with duplicates tRNA in this case
#if statement to break searching when a result is found
if((dim(found.result.match[[1]])[1])>0) {
gene.copy=1
gene.name <- as.character(genes.local$gene[1])
if(gene.name %in% duplicate.genes) {
gene.copy <- as.numeric(substr(gene.name, nchar(gene.name), nchar(gene.name)))
}
found.result <- found.result.match[[1]][gene.copy,]#subset results
boundaries[i, 1 + 2*j] <- found.result[2]#write the starting position
boundaries[i, 2 + 2*j] <- found.result[3]#write stop position
break
}
}
}
}
colnames(boundaries)<-c("Species","Accession",seq.col.id)#Add column names made above. Include
class(boundaries)<-append(class(boundaries),"Annot.Pos")#make object boundaries have class of Annot.Pos
boundaries
}
citation("MonoPhy")
test_that("Getting Sequence Positions from Annotations works",{
numbs<-c("FJ706343","FJ706292")
rdna.test.positions<-GetSeqPos(numbs, rDNA.Genes, bank = "genbank", duplicate.genes = NULL)
rdna.manual.positions<-read.csv("rdna_manualPositions.csv", header=TRUE, row.names = 1, stringsAsFactors = FALSE)
class(rdna.manual.positions)<-append(class(rdna.manual.positions),"Annot.Pos")#give the manual positions class Annot.Pos to check identicality
expect_that(rdna.test.positions, is_a("Annot.Pos"))#Check that it is of proper class Annot.Pos
expect_identical(dim(rdna.test.positions), dim(rdna.manual.positions))#test to see if same dimensions
expect_identical(rdna.test.positions[,1:2], rdna.manual.positions[,1:2])#test to see if they are the same
expect_identical(as.numeric(rdna.test.positions[,3:12]), as.numeric(rdna.manual.positions[,3:12]))#test to see if they are the same
})
test_that("Getting Sequence Positions from Annotations works",{
numbs<-c("FJ706343","FJ706292")
rdna.test.positions<-GetSeqPos(numbs, rDNA.Genes, duplicate.genes = NULL)
rdna.manual.positions<-read.csv("rdna_manualPositions.csv", header=TRUE, row.names = 1, stringsAsFactors = FALSE)
class(rdna.manual.positions)<-append(class(rdna.manual.positions),"Annot.Pos")#give the manual positions class Annot.Pos to check identicality
expect_that(rdna.test.positions, is_a("Annot.Pos"))#Check that it is of proper class Annot.Pos
expect_identical(dim(rdna.test.positions), dim(rdna.manual.positions))#test to see if same dimensions
expect_identical(rdna.test.positions[,1:2], rdna.manual.positions[,1:2])#test to see if they are the same
expect_identical(as.numeric(rdna.test.positions[,3:12]), as.numeric(rdna.manual.positions[,3:12]))#test to see if they are the same
})
library(stringr)
test_that("Getting Sequence Positions from Annotations works",{
numbs<-c("FJ706343","FJ706292")
rdna.test.positions<-GetSeqPos(numbs, rDNA.Genes, duplicate.genes = NULL)
rdna.manual.positions<-read.csv("rdna_manualPositions.csv", header=TRUE, row.names = 1, stringsAsFactors = FALSE)
class(rdna.manual.positions)<-append(class(rdna.manual.positions),"Annot.Pos")#give the manual positions class Annot.Pos to check identicality
expect_that(rdna.test.positions, is_a("Annot.Pos"))#Check that it is of proper class Annot.Pos
expect_identical(dim(rdna.test.positions), dim(rdna.manual.positions))#test to see if same dimensions
expect_identical(rdna.test.positions[,1:2], rdna.manual.positions[,1:2])#test to see if they are the same
expect_identical(as.numeric(rdna.test.positions[,3:12]), as.numeric(rdna.manual.positions[,3:12]))#test to see if they are the same
})
?str_extract_all
#' Finds annotation positions based on search terms that can later be used to seperate sequences into their annotated components.
#' @param accessions A vector of GenBank accession numbers.
#' @param genes A data frame of search terms. Pre-compiled search term lists are available as data with this package for mitogenomes and rDNA.
#' @param duplicate.genes A character vector containing duplicate gene names found in the annotation. Ex. serine and leucine in mitogenomes.
#' @return A table of start and stop positions of class annotPos for all the genes specified for all accession numbers that can be used to bust sequences using AnnotationBustR.
#' @example
#' ncbi.accessions<-c("FJ706343","FJ706292")#vector of two NCBI accession numbers to get the annotation positions of.
#' data(rDNA.Genes)#load rDNA search terms
#' my.seq.pos<-GetSeqPos(ncbi.accessions, )
#' @export
GetSeqPos<-function(accessions, genes, duplicate.genes =c("tRNA_Ser2", "tRNA_Leu2")){
seqinr::choosebank("genbank")#choose bank so it could be genbank or EMBL or others supported?
unique.gene.names <- unique(genes$gene)#unique gene names
seq.col.id<-paste(rep(as.vector(unique.gene.names),1,each=2),c("start","stop"),sep = ".")#these will be the column names for gene id
boundaries <- data.frame(matrix(nrow=length(accessions), ncol=2+2*length(unique.gene.names)))
#for each accession
for(i in sequence(length(accessions))){
new.access<-strsplit(accessions[i],"\\.",perl=TRUE)[[1]][1]#split and decimal spot in accession number. seqinr won't take them with it
rec<-seqinr::query(paste("AC=",new.access,sep=""))#get the genbank record. Getting error related to paste and it won't show accession, but it is working.
current.annot<-seqinr::getAnnot(rec$req[[1]],nbl=20000)#I think nbl is ok, but maybe we should up it to something ridiculous just to be safe
new.annot<-gsub("complement\\(|\\(|<"," ",current.annot)#kill complement()
new.annot<-gsub("\\)|>","",new.annot)#kill trailing ) after complemet
matching.lines.Leu<-which(grepl("tRNA-Leu|trnL|trnL-uaa|trnL TAA",new.annot))#find Leucine lines
new.annot[matching.lines.Leu[1]]<-sub("tRNA-Leu|trnL|trnL-uaa|trnL TAA","tRNA-Leu1",new.annot[matching.lines.Leu[1]])#sub 1st leucine instance
matching.lines.Ser<-which(grepl("tRNA-Ser|trnS|trnS-uga|trnS TGA",new.annot))#find serine lines
new.annot[matching.lines.Ser[1]]<-sub("tRNA-Ser|trnS|trnS-uga|trnS TGA","tRNA-Ser1",new.annot[matching.lines.Ser[1]])#sub first instance of serine
spec.name<- subset(gsub("  ORGANISM  ", "",stringr::str_extract_all(new.annot, "  ORGANISM  \\D+")),!(gsub("  ORGANISM  ", "",stringr::str_extract_all(new.annot, "  ORGANISM  \\D+"))=="character(0)"))#get species name
boundaries[i, 1] <- spec.name#add species name to final table
boundaries[i, 2] <- accessions[i]#add accession number to the final table
#for each gene
for (j in sequence(length(unique.gene.names))) {
genes.local <- subset(genes, genes$gene==unique.gene.names[j])#subset genes based on column 1 ID
found.result <- matrix(nrow=1, ncol=3)#make empty result so if nothing is found, it is NA
#for each search term combo
for (k in sequence(dim(genes.local)[1])) {
found.result.match <- stringr::str_match_all(paste(new.annot, collapse=" "), paste(genes.local[k,2],"\\s+(\\d+)..(\\d+)\\s*+/*",genes.local[k,3],"=*\\\"*", genes.local[k,4], "\\\"*", sep=""))#Match all cases for genes with duplicates tRNA in this case
#found.result.match <- str_match_all(paste(new.annot, collapse=" "), paste(genes[i,2],"\\s+(\\d+)..(\\d+)\\s+/",genes[i,3],"=\\\"", genes[i,4], "\\\"", sep=""))#Match all cases for genes with duplicates tRNA in this case
#found.result.match <- str_match_all(paste(new.annot, collapse=" "), paste(genes[i,2],"\\s+(\\d+)..(\\d+)\\s+/",genes[i,3], genes[i,4], sep=""))#Match all cases for genes with duplicates tRNA in this case
#if statement to break searching when a result is found
if((dim(found.result.match[[1]])[1])>0) {
gene.copy=1
gene.name <- as.character(genes.local$gene[1])
if(gene.name %in% duplicate.genes) {
gene.copy <- as.numeric(substr(gene.name, nchar(gene.name), nchar(gene.name)))
}
found.result <- found.result.match[[1]][gene.copy,]#subset results
boundaries[i, 1 + 2*j] <- found.result[2]#write the starting position
boundaries[i, 2 + 2*j] <- found.result[3]#write stop position
break
}
}
}
}
colnames(boundaries)<-c("Species","Accession",seq.col.id)#Add column names made above. Include
class(boundaries)<-append(class(boundaries),"Annot.Pos")#make object boundaries have class of Annot.Pos
boundaries
}
numbs<-c("FJ706343","FJ706292")
rdna.test.positions<-GetSeqPos(numbs, rDNA.Genes, duplicate.genes = NULL)
rdna.test.positions<-GetSeqPos(numbs, rDNA.Genes, duplicate.genes = NULL)
rdna.test.positions
rdna.manual.positions<-read.csv("rdna_manualPositions.csv", header=TRUE, row.names = 1, stringsAsFactors = FALSE)
rdna.manual.positions
rDNA.Genes
rdna.test.positions
test_that("Getting Sequence Positions from Annotations works",{
numbs<-c("FJ706343","FJ706292")
rdna.test.positions<-GetSeqPos(numbs, rDNA.Genes, duplicate.genes = NULL)
rdna.manual.positions<-read.csv("rdna_manualPositions.csv", header=TRUE, row.names = 1, stringsAsFactors = FALSE)
class(rdna.manual.positions)<-append(class(rdna.manual.positions),"Annot.Pos")#give the manual positions class Annot.Pos to check identicality
expect_that(rdna.test.positions, is_a("Annot.Pos"))#Check that it is of proper class Annot.Pos
expect_identical(dim(rdna.test.positions), dim(rdna.manual.positions))#test to see if same dimensions
expect_identical(rdna.test.positions[,1:2], rdna.manual.positions[,1:2])#test to see if they are the same
expect_identical(as.numeric(rdna.test.positions[,3:12]), as.numeric(rdna.manual.positions[,3:12]))#test to see if they are the same
})
rdna.test.positions<-GetSeqPos(numbs, rDNA.Genes, duplicate.genes = NULL)
rdna.test.positions
rdna.manual.positions
rdna.manual.positions<-read.csv("rdna_manualPositions.csv", header=TRUE, row.names = 1, stringsAsFactors = FALSE)
rdna.manual.positions
class(rdna.manual.positions)<-append(class(rdna.manual.positions),"Annot.Pos")#give the manual positions class Annot.Pos to check identicality
rdna.manual.positions
expect_that(rdna.test.positions, is_a("Annot.Pos"))#Check that it is of proper class Annot.Pos
expect_that(rdna.test.positions, !is_a("Annot.Pos"))#Check that it is of proper class Annot.Pos
expect_that(rdna.test.positions, is_a("Matrix"))#Check that it is of proper class Annot.Pos
expect_that(rdna.test.positions, is_a("Annot.Pos"))#Check that it is of proper class Annot.Pos
expect_identical(dim(rdna.test.positions), dim(rdna.manual.positions))#test to see if same dimensions
expect_identical(dim(rdna.test.positions[1:2]), dim(rdna.manual.positions))#test to see if same dimensions
expect_identical(dim(rdna.test.positions), dim(rdna.manual.positions))#test to see if same dimensions
expect_identical(rdna.test.positions[,1:2], rdna.manual.positions[,1:2])#test to see if they are the same
expect_identical(as.numeric(rdna.test.positions[,3:12]), as.numeric(rdna.manual.positions[,3:12]))#test to see if they are the same
as.numeric(rdna.test.positions[,3:12]
)
rdna.test.positions[,3:12]
rdna.manual.positions[,3:12]
expect_identical(rdna.test.positions, rdna.manual.positions)
expect_identical(rdna.test.positions[3:12], rdna.manual.positions[3:12])
as.numeric(rdna.test.positions[,3:12])
rdna.test.positions[,3:12]
as.numeric(rdna.manual.positions[,3:12])
rdna.test.positions
class(rdna.test.positions)
expect_identical(as.data.frame(rdna.test.positions[,3:12]), as.data.frame(rdna.manual.positions[,3:12]))#test to see if they are the same
str(rdna.manual.positions)
str(rdna.test.positions)
rdna.test.positions[,3:12]
rdna.manual.positions[,3:12]
colnames(rdna.manual.positions)==colnames(rdna.test.positions)
colnames(rdna.manual.positions)<-colnames(rdna.test.positions)
colnames(rdna.test.positions)
colnames(rdna.manual.positions)
expect_identical(as.numeric(rdna.test.positions[,3:12]), as.numeric(rdna.manual.positions[,3:12]))#test to see if they are the same
expect_identical(as.numeric(rdna.test.positions[,3:12]), as.numeric(rdna.manual.positions[,3:12]))#test to see if they are the same
is.list(rdna.manual.positions)
unlist(rdna.manual.positions)
expect_identical(rdna.test.positions[3:12], rdna.manual.positions[3:12])
as.numeric(rdna.manual.positions[,3:12])
expect_identical(as.numeric(unlist(rdna.test.positions[,3:12])), as.numeric(unlist(rdna.manual.positions[,3:12]))#test to see if they are the same
expect_identical(as.numeric(unlist(rdna.test.positions[,3:12])), as.numeric(unlist(rdna.manual.positions[,3:12])))#test to see if they are the same
test_that("Getting Sequence Positions from Annotations works",{
numbs<-c("FJ706343","FJ706292")
rdna.test.positions<-GetSeqPos(numbs, rDNA.Genes, duplicate.genes = NULL)
rdna.manual.positions<-read.csv("rdna_manualPositions.csv", header=TRUE, row.names = 1, stringsAsFactors = FALSE)
class(rdna.manual.positions)<-append(class(rdna.manual.positions),"Annot.Pos")#give the manual positions class Annot.Pos to check identicality
expect_that(rdna.test.positions, is_a("Annot.Pos"))#Check that it is of proper class Annot.Pos
expect_identical(dim(rdna.test.positions), dim(rdna.manual.positions))#test to see if same dimensions
expect_identical(rdna.test.positions[,1:2], rdna.manual.positions[,1:2])#test to see if they are the same
expect_identical(as.numeric(unlist(rdna.test.positions[,3:12])), as.numeric(unlist(rdna.manual.positions[,3:12])))#test to see if they are the same
})
rdna.manual.positions
rdna.test.positions
rdna.manual.positions
rdna.manual.positions<-read.csv("rdna_manualPositions.csv", header=TRUE, row.names = 1, stringsAsFactors = FALSE)
rdna.manual.positions
test_that("Getting Sequence Positions from Annotations works",{
numbs<-c("FJ706343","FJ706292")
rdna.test.positions<-GetSeqPos(numbs, rDNA.Genes, duplicate.genes = NULL)
rdna.manual.positions<-read.csv("rdna_manualPositions.csv", header=TRUE, row.names = 1, stringsAsFactors = FALSE)
class(rdna.manual.positions)<-append(class(rdna.manual.positions),"Annot.Pos")#give the manual positions class Annot.Pos to check identicality
expect_that(rdna.test.positions, is_a("Annot.Pos"))#Check that it is of proper class Annot.Pos
expect_identical(dim(rdna.test.positions), dim(rdna.manual.positions))#test to see if same dimensions
expect_identical(rdna.test.positions[,1:2], rdna.manual.positions[,1:2])#test to see if they are the same
expect_identical(as.numeric(unlist(rdna.test.positions[,3:12])), as.numeric(unlist(rdna.manual.positions[,3:12])))#test to see if they are the same
})
rDNA.Genes<-read.csv("rDNA.csv")
rDNA
rDNA.Genes
save.image("~/GitHub/AnnotationBustR/data/rDNAGenes.RData")
load("C:/Users/Sam/Documents/GitHub/AnnotationBustR/data/rDNAGenes.RData")
load("C:/Users/Sam/Documents/GitHub/AnnotationBustR/data/rDNA_Genes.RData")
#' Finds annotation positions based on search terms that can later be used to seperate sequences into their annotated components.
#' @param accessions A vector of GenBank accession numbers.
#' @param genes A data frame of search terms. Pre-compiled search term lists are available as data with this package for mitogenomes and rDNA.
#' @param duplicate.genes A character vector containing duplicate gene names found in the annotation. Ex. serine and leucine in mitogenomes.
#' @return A table of start and stop positions of class annotPos for all the genes specified for all accession numbers that can be used to bust sequences using AnnotationBustR.
#' @example
#' ncbi.accessions<-c("FJ706343","FJ706292")#vector of two NCBI accession numbers to get the annotation positions of.
#' data(rDNA.Genes)#load rDNA search terms
#' my.seq.pos<-GetSeqPos(ncbi.accessions, )
#' @export
GetSeqPos<-function(accessions, genes, duplicate.genes =c("tRNA_Ser2", "tRNA_Leu2")){
seqinr::choosebank("genbank")#choose bank so it could be genbank or EMBL or others supported?
unique.gene.names <- unique(genes$gene)#unique gene names
seq.col.id<-paste(rep(as.vector(unique.gene.names),1,each=2),c("start","stop"),sep = ".")#these will be the column names for gene id
boundaries <- data.frame(matrix(nrow=length(accessions), ncol=2+2*length(unique.gene.names)))
#for each accession
for(i in sequence(length(accessions))){
new.access<-strsplit(accessions[i],"\\.",perl=TRUE)[[1]][1]#split and decimal spot in accession number. seqinr won't take them with it
rec<-seqinr::query(paste("AC=",new.access,sep=""))#get the genbank record. Getting error related to paste and it won't show accession, but it is working.
current.annot<-seqinr::getAnnot(rec$req[[1]],nbl=20000)#I think nbl is ok, but maybe we should up it to something ridiculous just to be safe
new.annot<-gsub("complement\\(|\\(|<"," ",current.annot)#kill complement()
new.annot<-gsub("\\)|>","",new.annot)#kill trailing ) after complemet
matching.lines.Leu<-which(grepl("tRNA-Leu|trnL|trnL-uaa|trnL TAA",new.annot))#find Leucine lines
new.annot[matching.lines.Leu[1]]<-sub("tRNA-Leu|trnL|trnL-uaa|trnL TAA","tRNA-Leu1",new.annot[matching.lines.Leu[1]])#sub 1st leucine instance
matching.lines.Ser<-which(grepl("tRNA-Ser|trnS|trnS-uga|trnS TGA",new.annot))#find serine lines
new.annot[matching.lines.Ser[1]]<-sub("tRNA-Ser|trnS|trnS-uga|trnS TGA","tRNA-Ser1",new.annot[matching.lines.Ser[1]])#sub first instance of serine
spec.name<- subset(gsub("  ORGANISM  ", "",stringr::str_extract_all(new.annot, "  ORGANISM  \\D+")),!(gsub("  ORGANISM  ", "",stringr::str_extract_all(new.annot, "  ORGANISM  \\D+"))=="character(0)"))#get species name
boundaries[i, 1] <- spec.name#add species name to final table
boundaries[i, 2] <- accessions[i]#add accession number to the final table
#for each gene
for (j in sequence(length(unique.gene.names))) {
genes.local <- subset(genes, genes$gene==unique.gene.names[j])#subset genes based on column 1 ID
found.result <- matrix(nrow=1, ncol=3)#make empty result so if nothing is found, it is NA
#for each search term combo
for (k in sequence(dim(genes.local)[1])) {
found.result.match <- stringr::str_match_all(paste(new.annot, collapse=" "), paste(genes.local[k,2],"\\s+(\\d+)..(\\d+)\\s*+/*",genes.local[k,3],"=*\\\"*", genes.local[k,4], "\\\"*", sep=""))#Match all cases for genes with duplicates tRNA in this case
#found.result.match <- str_match_all(paste(new.annot, collapse=" "), paste(genes[i,2],"\\s+(\\d+)..(\\d+)\\s+/",genes[i,3],"=\\\"", genes[i,4], "\\\"", sep=""))#Match all cases for genes with duplicates tRNA in this case
#found.result.match <- str_match_all(paste(new.annot, collapse=" "), paste(genes[i,2],"\\s+(\\d+)..(\\d+)\\s+/",genes[i,3], genes[i,4], sep=""))#Match all cases for genes with duplicates tRNA in this case
#if statement to break searching when a result is found
if((dim(found.result.match[[1]])[1])>0) {
gene.copy=1
gene.name <- as.character(genes.local$gene[1])
if(gene.name %in% duplicate.genes) {
gene.copy <- as.numeric(substr(gene.name, nchar(gene.name), nchar(gene.name)))
}
found.result <- found.result.match[[1]][gene.copy,]#subset results
boundaries[i, 1 + 2*j] <- found.result[2]#write the starting position
boundaries[i, 2 + 2*j] <- found.result[3]#write stop position
break
}
}
}
}
colnames(boundaries)<-c("Species","Accession",seq.col.id)#Add column names made above. Include
class(boundaries)<-append(class(boundaries),"Annot.Pos")#make object boundaries have class of Annot.Pos
boundaries
}
test_that("Getting Sequence Positions from Annotations works",{
numbs<-c("FJ706343","FJ706292")
rdna.test.positions<-GetSeqPos(numbs, rDNA.Genes, duplicate.genes = NULL)
rdna.manual.positions<-read.csv("rdna_manualPositions.csv", header=TRUE, row.names = 1, stringsAsFactors = FALSE)
class(rdna.manual.positions)<-append(class(rdna.manual.positions),"Annot.Pos")#give the manual positions class Annot.Pos to check identicality
expect_that(rdna.test.positions, is_a("Annot.Pos"))#Check that it is of proper class Annot.Pos
expect_identical(dim(rdna.test.positions), dim(rdna.manual.positions))#test to see if same dimensions
expect_identical(rdna.test.positions[,1:2], rdna.manual.positions[,1:2])#test to see if they are the same
expect_identical(as.numeric(unlist(rdna.test.positions[,3:12])), as.numeric(unlist(rdna.manual.positions[,3:12])))#test to see if they are the same
})
#Test to see if annotation positions are found correctly
aaaa<-test_that("Getting Sequence Positions from Annotations works",{
numbs<-c("FJ706343","FJ706292")
rdna.test.positions<-GetSeqPos(numbs, rDNA.Genes, duplicate.genes = NULL)
rdna.manual.positions<-read.csv("rdna_manualPositions.csv", header=TRUE, row.names = 1, stringsAsFactors = FALSE)
class(rdna.manual.positions)<-append(class(rdna.manual.positions),"Annot.Pos")#give the manual positions class Annot.Pos to check identicality
expect_that(rdna.test.positions, is_a("Annot.Pos"))#Check that it is of proper class Annot.Pos
expect_identical(dim(rdna.test.positions), dim(rdna.manual.positions))#test to see if same dimensions
expect_identical(rdna.test.positions[,1:2], rdna.manual.positions[,1:2])#test to see if they are the same
expect_identical(as.numeric(unlist(rdna.test.positions[,3:12])), as.numeric(unlist(rdna.manual.positions[,3:12])))#test to see if they are the same
})
aaaa
citation(seqinr)
citation(package=seqinr)
citation(package="seqinr")
citation(package="stringr")
citation(package="traits")
